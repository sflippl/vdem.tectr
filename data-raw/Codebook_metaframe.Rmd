---
title: "Codebook: Reading in the variable information"
author: "Samuel Lippl"
date: "19 Juli 2018"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(devtools)
library(pdftools)
library(glue)
library(purrr)
library(tectr)
```

This document reads in the codebook and determines the indicator info.

# Preparations

```{r}
load_all()
pdffile <- system.file("extdata", "Country_Year_V-Dem_Extended_STATA_v8",
                       "V-DEM Codebook V8.pdf", 
                       package = "vdem.tectr")
codebook <- pdf_text(pdffile)
codebook_toc <- pdf_toc(pdffile)
```

The indicator information can be found in Part II to VI:

```{r}
ind_info <- codebook_toc$children[2:6]
```

The title of the part (level 1) denotes some general description that may or may
not be useful - it will be called part.
Example:

```{r}
ind_info[[1]]$title
```

The title of the chapter denotes a specific form of data. Example:

```{r}
ind_info[[1]]$children[[1]]$title
```

Finally the title of the section (level 3) describes the indicator itself.
Example:

```{r}
ind_info[[1]]$children[[1]]$children[[1]]$title
```

It has no children:

```{r}
ind_info[[1]]$children[[1]]$children[[1]]$children
```

Moreover its structure is: " <Alias> (<Type>) (<Name>)"

In order to make sure that we do not extract the table of contents, we extract the relevant components of the codebook:

```{r}
codebook2 <- codebook[41:341] %>% str_split("\r\n") %>% unlist
rm(codebook)
```

We will begin by clearing some irrelevant lines, in particular the page numbers:

```{r}
page_numbers <- str_detect(codebook2, pattern = "^\\s+\\d+$") %>% which
codebook2 <- codebook2[-page_numbers]
```

Furthermore, hyphens at the end of a line normally signify that the word will be continued in the next line. I will treat it like that - the assumption being that this will prevent more errors than it causes and the errors it causes are either easy to treat or do not pose significant problems.

```{r}
hyphen_end <- str_detect(codebook2, pattern = "-$")
it_cod <- 1
for(it_hyph in hyphen_end) {
  if(it_hyph) {
    codebook2[it_cod] <- 
      paste0(
        str_sub(codebook2[it_cod], end = -2L), 
        str_trim(codebook2[it_cod + 1])
      )
    codebook2 <- codebook2[-(it_cod + 1)]
  }
  else it_cod <- it_cod + 1
}
```

The other reason why headers might be separated along lines is a comma:

```{r}
comma_end <- str_detect(codebook2, pattern = ",$")
it_cod <- 1
for(it_comma in comma_end) {
  if(it_comma) {
    codebook2[it_cod] <- 
      paste(
        codebook2[it_cod], 
        str_trim(codebook2[it_cod + 1])
      )
    codebook2 <- codebook2[-(it_cod + 1)]
  }
  else it_cod <- it_cod + 1
}
```

Furthermore, if the next line starts with some punctuation, it is normally not a "natural" line start but affects some new lines:

```{r}
cont_punct <- str_detect(codebook2, pattern = "^\\s*[:punct:]")
it_cod <- 0
for(it_punct in cont_punct) {
  if(it_punct) {
    codebook2[it_cod] <- 
      paste0(
        codebook2[it_cod], 
        str_trim(codebook2[it_cod + 1])
      )
    codebook2 <- codebook2[-(it_cod + 1)]
  }
  else it_cod <- it_cod + 1
}
```


We can now start partitioning the document. `codebook2` must therefore not be changed from now on! First, we extract the parts:

```{r}
parts <- str_detect(codebook2, pattern = "^\\d\\s+") %>% which
tbl_parts <- tibble(
  part_num = str_sub(codebook2[parts], end = 1L) %>% as.numeric, 
  part_title = str_replace(codebook2[parts], pattern = "^\\d\\s+", 
                      replacement = ""), 
  part_position = parts
)
tbl_parts
```

The next step are the chapters.

```{r}
chapters <- str_detect(codebook2, pattern = "^\\d\\.\\d+\\s+") %>% which
tbl_chapters <- tibble(
  part_num = str_sub(codebook2[chapters], end = 1L) %>% as.numeric, 
  chapter_num = c(str_match(codebook2[chapters], pattern = "(?<=.)\\d+")) %>% 
    as.numeric, 
  chapter_title = str_replace(codebook2[chapters], pattern = "^\\d\\.\\d+\\s+", 
                              replacement = ""), 
  chapter_position = chapters
)
tbl_chapters
```

Now we dissect the sections.

```{r}
sections <- str_detect(codebook2, pattern = "^\\d\\.\\d+\\.\\d+\\s+") %>% which
section_headers <- str_match(
  codebook2[sections], 
  pattern = "^(\\d)\\.(\\d+)\\.(\\d+)\\s+(.+)\\(([^\\(\\)]+)\\)\\s*\\(([^\\(\\)]+)\\)\\s*$"
)
tbl_sections1 <- tibble(
  part_num = section_headers[,2] %>% as.integer, 
  chapter_num = section_headers[,3] %>% as.integer, 
  ind_num = section_headers[,4] %>% as.integer, 
  ind_name_external = section_headers[,5] %>% str_trim, 
  ind_type = section_headers[,6] %>% 
    str_replace_all(pattern = "\\s", replacement = ""),
  ind_name = section_headers[,7],
  ind_position = sections
)
```


We are now concerned with analyzing the body of the different tibbles. This is easy for parts and chapters as the body is simply a set of lines that belong together. At first we generate a tibble that gives the end of every body given the beginning position:

```{r}
tbl_sort <- tibble(
  beginning_position = sort(
    c(
      tbl_parts$part_position, 
      tbl_chapters$chapter_position, 
      tbl_sections1$ind_position
    )
  )
) %>% 
  mutate(
    end_position = lead(beginning_position, default = length(codebook2) + 1) - 1
  )
```

```{r}
tbl_parts2 <- tbl_parts %>% 
  left_join(tbl_sort, c("part_position" = "beginning_position")) %>% 
  mutate(part_description = vapply(
    X = as.list(seq_len(nrow(.))), 
    FUN = function(i) {
      i_begin <- magrittr::extract2(., "part_position") %>% magrittr::extract(i)
      i_end <- magrittr::extract2(., "end_position") %>% magrittr::extract(i)
      if(i_begin == i_end) return("")
      paste(
        codebook2[(i_begin + 1):i_end], 
        collapse =" "
      )
    }, 
    FUN.VALUE = character(1)
  ) %>% str_trim) %>% select(-end_position)
tbl_parts2
```

```{r}
tbl_chapters2 <- tbl_chapters %>% 
  left_join(tbl_sort, c("chapter_position" = "beginning_position")) %>% 
  mutate(chapter_description = vapply(
    X = as.list(seq_len(nrow(.))), 
    FUN = function(i) {
      i_begin <- magrittr::extract2(., "chapter_position") %>% magrittr::extract(i)
      i_end <- magrittr::extract2(., "end_position") %>% magrittr::extract(i)
      if(i_begin == i_end) return("")
      paste(
        codebook2[(i_begin + 1):i_end], 
        collapse =" "
      )
    }, 
    FUN.VALUE = character(1)
  ) %>% str_trim) %>% select(-end_position)
tbl_chapters2
```

It remains to deal with the indicator descriptions which is the most important part. While we may split this tibble later, for now it makes sense to leave all descriptions in one tibble. We note that every indicator description consists of different topic that are marked by two spaces, a description and a ":", e. g.:

```{r}
codebook2[7]
```

we extract all these lines and make a manual exception:

```{r}
categories <- str_detect(codebook2, "^  \\S[^:]+:") & 
  !str_detect(codebook2, "^  The index is aggregated using this formula:")
```

We may now modify `tbl_sort`:

```{r}
tbl_sort2 <- tibble(
  beginning_position = sort(
    c(
      tbl_parts$part_position, 
      tbl_chapters$chapter_position, 
      tbl_sections1$ind_position, 
      categories %>% which
    )
  )
) %>% 
  mutate(
    end_position = lead(beginning_position, default = length(codebook2) + 1) - 1
  )
```

Finally, we can split every description into a category and a list column of character vectors (for now - later this will be merged appropriately).

```{r}
category_descriptions <- str_match(codebook2[categories], 
                                   pattern = "^  (\\S[^:]+):\\s*(.*)$")
tbl_categories <- tibble(
  category = category_descriptions[, 2], 
  description = category_descriptions[, 3], 
  category_position = categories %>% which
) %>% 
  mutate(
    description = lapply(
      category_position, 
      FUN = function(x) {
        nxt <- tbl_sort2 %>% filter(beginning_position == x) %>%
          magrittr::extract2("end_position")
        ret <- filter(., category_position == x) %>% 
                 magrittr::extract2("description")
        if(nxt == x) return(ret)
        c(ret, codebook2[(x + 1):nxt])
      }
    ), 
    ind_position = vapply(
      category_position, 
      FUN = function(x) {
        tbl_sections1$ind_position %>% magrittr::extract(. < x) %>% 
          max
      },
      FUN.VALUE = numeric(1)
    )
  ) %>% 
  right_join(tbl_sections1, ., by = "ind_position") %>% 
  select(-ind_position, -category_position) %>% 
  spread(key = "category", value = "description")
```

We will now modify the specific descriptions columns.

## Aggregation

```{r}
agg_not_null <- !sapply(tbl_categories$Aggregation, is.null)
head(tbl_categories$Aggregation[agg_not_null], 1)
```

Clearly, this is simply a description of the aggregation mechanism. It can thus be safely concatenated:

```{r}
tbl_categories <- mutate(
  tbl_categories, 
  fxInfo_aggregation = vapply(
    Aggregation, 
    FUN = function(x) {
      if(is.null(x)) return("")
      paste(str_trim(x), collapse = " ")
    }, 
    FUN.VALUE = character(1)
  ) %>% str_trim
) %>% select(-Aggregation)
```

## Answer-type

```{r}
ans_not_null <- !sapply(tbl_categories$`Answer-type`, is.null)
head(tbl_categories$`Answer-type`[ans_not_null], 5)
```

Clearly also simply a description.

```{r}
tbl_categories <- mutate(
  tbl_categories, 
  fxInfo_answer_type = vapply(
    `Answer-type`, 
    FUN = function(x) {
      if(is.null(x)) return("")
      paste(str_trim(x), collapse = " ")
    }, 
    FUN.VALUE = character(1)
  )
) %>% select(-`Answer-type`)
```

According to the codebook, by default, the answer type is multiple choice. We will therefore adapt the tibble accordingly. Furthermore, there are different descriptions of multiple selection:

```{r}
unique(tbl_categories$answer_type)
```

```{r}
tbl_categories <- mutate(
  tbl_categories, 
  fxInfo_answer_type = factor(fxInfo_answer_type) %>% 
    fct_recode(
      `Multiple Choice` = "", 
      `Multiple Selection` = "Multiple selection.", 
      `Multiple Selection` = "Multiple-selection", 
      `Multiple Selection` = "Multiple selection ", 
      `Multiple Selection` = "Multiple-selection.", 
      `Multiple Selection` = "Multiple selection"
    )
)
```

## Citation

```{r}
cit_not_null <- !sapply(tbl_categories$Citation, is.null)
head(tbl_categories$Citation[cit_not_null], 5)
```

For now, it is sufficient to simply parse the suggested citation.

```{r}
tbl_categories <- mutate(
  tbl_categories, 
  fxInfo_citation = vapply(
    Citation, 
    FUN = function(x) {
      if(is.null(x)) return("")
      paste(str_trim(x), collapse = " ")
    }, 
    FUN.VALUE = character(1)
  ) %>% str_trim
) %>% select(-Citation)
```

## Clarification

```{r}
cla_not_null <- !sapply(tbl_categories$Clarification, is.null)
head(tbl_categories$Clarification[cla_not_null], 5)
```

This is clearly a description.

```{r}
tbl_categories <- mutate(
  tbl_categories, 
  fxInfo_clarification = vapply(
    Clarification, 
    FUN = function(x) {
      if(is.null(x)) return("")
      paste(str_trim(x), collapse = " ")
    }, 
    FUN.VALUE = character(1)
  ) %>% str_trim
) %>% select(-Clarification)
```

## CPP tag

```{r}
cpp_not_null <- !sapply(tbl_categories$`CPP tag`, is.null)
head(tbl_categories$`CPP tag`[cpp_not_null], 5)
```

This seems to be specific to the comparative constitutional project. I will leave it in, however.

```{r}
tbl_categories <- mutate(
  tbl_categories, 
  fxInfo_cpp_tag = vapply(
    `CPP tag`, 
    FUN = function(x) {
      if(is.null(x)) return("")
      paste(str_trim(x), collapse = " ")
    }, 
    FUN.VALUE = character(1)
  ) %>% str_trim %>% factor
) %>% select(-`CPP tag`)
```

## Cross-coder aggreement

```{r}
cross_not_null <- !sapply(tbl_categories$`Cross-coder aggregation`, is.null)
head(tbl_categories$`Cross-coder aggregation`[cross_not_null], 5)
```

Seems to be a factor.

```{r}
tbl_categories <- mutate(
  tbl_categories, 
  fxInfo_cross_coder_aggregation = vapply(
    `Cross-coder aggregation`, 
    FUN = function(x) {
      if(is.null(x)) return("")
      paste(str_trim(x), collapse = " ")
    }, 
    FUN.VALUE = character(1)
  ) %>% str_trim %>% factor
) %>% select(-`Cross-coder aggregation`)
```

There are some typos:

```{r}
levels(tbl_categories$fxInfo_cross_coder_aggregation)
```

```{r}
tbl_categories <- mutate(
  tbl_categories, 
  fxInfo_cross_coder_aggregation =
    fct_recode(
      fxInfo_cross_coder_aggregation, 
      `Bayesian Item Response Theory Measurement Model` = 
        "Bayesian item response theory measurement model (see V-Dem Method ology).", 
      `Bayesian Item Response Theory Measurement Model` = 
        "Bayesian item response theory measurement model (see V-Dem Methodology", 
      `Bayesian Item Response Theory Measurement Model` = 
        "Bayesian item response theory measurement model (see V-Dem Methodology)", 
      `Bayesian Item Response Theory Measurement Model` = 
        "Bayesian item response theory measurement model (see V-Dem Methodology).", 
      `Bayesian Item Response Theory Measurement Model` = 
        "Bayesian item response theory measurement model (see V-Dem Methodology, posted at V-Dem.net).", 
      `Bayesian Item Response Theory Measurement Model` = 
        "Bayesian item response theory measurement model (see V-Dem Methodology,).", 
      Bootstrapped = "Bootstrapped.", 
      Mean = "Mean."
    )
)
```

## Data release

```{r}
rel_not_null <- !sapply(tbl_categories$`Data release`, is.null)
head(tbl_categories$`Data release`[rel_not_null], 5)
```

Seems to be a description (although factor might be applicable with some cleaning.)

```{r}
tbl_categories <- mutate(
  tbl_categories, 
  fxInfo_data_release = vapply(
    `Data release`, 
    FUN = function(x) {
      if(is.null(x)) return("")
      paste(str_trim(x), collapse = " ")
    }, 
    FUN.VALUE = character(1)
  ) %>% str_trim
) %>% select(-`Data release`)
```

## Historical Clarification

```{r}
hist_not_null <- !sapply(tbl_categories$`Historical Clarification`, is.null)
head(tbl_categories$`Historical Clarification`[hist_not_null], 5)
```

Some additional description.

```{r}
tbl_categories <- mutate(
  tbl_categories, 
  fxInfo_historical_clarification = vapply(
    `Historical Clarification`, 
    FUN = function(x) {
      if(is.null(x)) return("")
      paste(str_trim(x), collapse = " ")
    }, 
    FUN.VALUE = character(1)
  ) %>% str_trim
) %>% select(-`Historical Clarification`)
```

## Notes

```{r}
notes_not_null <- !sapply(tbl_categories$Notes, is.null)
head(tbl_categories$Notes[notes_not_null], 5)
```

Some more description.

```{r}
tbl_categories <- mutate(
  tbl_categories, 
  fxInfo_notes = vapply(
    Notes, 
    FUN = function(x) {
      if(is.null(x)) return("")
      paste(str_trim(x), collapse = " ")
    }, 
    FUN.VALUE = character(1)
  ) %>% str_trim %>% factor
) %>% select(-Notes)
```


## Ordering

```{r}
ordering_not_null <- !sapply(tbl_categories$Ordering, is.null)
head(tbl_categories$Ordering[ordering_not_null], 5)
```

More description.

```{r}
tbl_categories <- mutate(
  tbl_categories, 
  fxInfo_ordering = vapply(
    Ordering, 
    FUN = function(x) {
      if(is.null(x)) return("")
      paste(str_trim(x), collapse = " ")
    }, 
    FUN.VALUE = character(1)
  ) %>% str_trim
) %>% select(-Ordering)
```

## Project Manager

```{r}
manager_not_null <- !sapply(tbl_categories$`Project Manager(s)`, is.null)
head(tbl_categories$`Project Manager(s)`[manager_not_null], 5)
```

This is a variable where it seems sensible to do some more cleaning. Every observation will consist of a factor vector consisting of the different Project Managers. First of all, we convert them to a single character vector:

```{r}
tbl_categories <- mutate(
  tbl_categories, 
  fxInfo_project_manager = vapply(
    `Project Manager(s)`, 
    FUN = function(x) {
      if(is.null(x)) return("")
      paste(str_trim(x), collapse = " ")
    }, 
    FUN.VALUE = character(1)
  ) %>% str_trim
) %>% select(-`Project Manager(s)`)
```

We can see that the different names are split by ", " or " and ". As there is one instance of ", and ", we use that as well.

```{r}
tbl_categories <- mutate(
  tbl_categories, 
  fxInfo_project_manager = str_split(fxInfo_project_manager, ", and |, | and ") %>% 
    lapply(function(x) {
      if(length(x) == 1 && x == "") return(character(0))
      x
    })
)
```

We then define a factor with all possible project managers as levels:

```{r}
project_manager_levels <- unlist(tbl_categories$fxInfo_project_manager) %>% unique
tbl_categories <- mutate(
  tbl_categories, 
  fxInfo_project_manager = lapply(
    fxInfo_project_manager, 
    function(x) factor(x, levels = project_manager_levels)
  )
)
```

## Question

```{r}
question_not_null <- !sapply(tbl_categories$Question, is.null)
head(tbl_categories$Question[question_not_null], 5)
```

Description.

```{r}
tbl_categories <- mutate(
  tbl_categories, 
  fxInfo_question = vapply(
    Question, 
    FUN = function(x) {
      if(is.null(x)) return("")
      paste(str_trim(x), collapse = " ")
    }, 
    FUN.VALUE = character(1)
  ) %>% str_trim
) %>% select(-Question)
```

## Responses

```{r}
resp_not_null <- !sapply(tbl_categories$Responses, is.null)
head(tbl_categories$Responses[resp_not_null], 5)
```

This is a bit harder to clean and will take several iterations. For now, I will simply rename it.

```{r}
tbl_categories <- mutate(tbl_categories, 
  fxInfo_responses = Responses %>% 
  map(function(str) {
    concatenated <- str_trim(str) %>% str_c(collapse = " ") %>% str_trim()
    split <- str_split(concatenated, "\\s+(?=\\d{1,3}\\s{0,2}:\\s)") %>% unlist
    split_no_s <- split[split != ""]
    if(length(split_no_s) == 1) return(split_no_s)
    named <- str_split_fixed(split_no_s, "(?<=\\d{1,3})\\s{0,2}:\\s", n = 2)
    ret <- tibble(key = named[, 1], value = named[, 2])
  })
) %>% select(-Responses)
```

## Scale

```{r}
scale_not_null <- !sapply(tbl_categories$Scale, is.null)
head(tbl_categories$Scale[scale_not_null], 5)
```

Inspecting the category more detailed, we find that there are not that many different scales:

```{r}
unique(tbl_categories$Scale)
```

There will be even fewer once the variable has been cleaned.


```{r}
tbl_categories <- mutate(
  tbl_categories, 
  fxInfo_scale = vapply(
    Scale, 
    FUN = function(x) {
      if(is.null(x)) return("")
      paste(str_trim(x), collapse = " ")
    }, 
    FUN.VALUE = character(1)
  ) %>% str_trim %>% str_replace(".$", "")
) %>% select(-Scale)
```

There are considerable overlaps due to typos:

```{r}
unique(tbl_categories$fxInfo_scale)
```

## Sources

```{r}
src_not_null <- !sapply(tbl_categories$`Source(s)`, is.null)
head(tbl_categories$`Source(s)`[src_not_null], 5)
```

Sources for the type A variables. We simply join them.

```{r}
tbl_categories <- mutate(
  tbl_categories, 
  fxInfo_sources = vapply(
    `Source(s)`, 
    FUN = function(x) {
      if(is.null(x)) return("")
      paste(str_trim(x), collapse = " ") %>% 
        str_trim()
    }, 
    FUN.VALUE = character(1)
  )
) %>% select(-`Source(s)`)
# use_data(tbl_categories)
```

# Miscellaneous Changes

There is a typo in the name "e_ Fiscal_Reliance".

```{r}
tbl_categories <- mutate(tbl_categories, 
                         ind_name = if_else(ind_name == "e_ Fiscal_Reliance", 
                                            "e_Fiscal_Reliance", ind_name))
```


# Metaframe

Finally, we create the metaframe file structure:

```{r}
metaframe <- 
  rename(tbl_categories, name = ind_name, fxInfo_label = ind_name_external) %>%
  inner_join(select(tbl_parts, part_num, part_title), by = "part_num") %>% 
  inner_join(select(tbl_chapters, chapter_num, chapter_title, part_num), 
             by = c("part_num", "chapter_num")) %>% 
  group_by(part_num, chapter_num, ind_num)
path <- paste0(system.file("inst", "extdata", 
                                                   package = "vdem.tectr"), 
                                       "/metaframe")
mf_revisable <- fx_write_json(metaframe, 
                              path = path, 
                              main = str_subset(names(metaframe), "^fxInfo_"))
use_data(mf_revisable, overwrite = TRUE)
```

